import re
from typing import List, Dict


def get_cased_identifiers(schema_identifiers: Dict[str, List[str]]) -> List[str]:
    """
    From the schema, find all identifiers (tables, columns) that contain
    at least one uppercase letter and therefore require quoting.
    """
    cased_identifiers = set()

    for item_type in ["tables", "columns"]:
        for identifier in schema_identifiers.get(item_type, []):
            if not identifier.islower():
                cased_identifiers.add(identifier)

    # Return as a sorted list, longest first to avoid partial matches (e.g., "Course" before "Course_ID")
    return sorted(list(cased_identifiers), key=len, reverse=True)


def fix_sql_casing(query: str, cased_identifiers: List[str]) -> str:
    """
    Programmatically finds and fixes casing errors in a given SQL query.
    It wraps any identifier that should be cased in double quotes.

    Args:
        query: The SQL query generated by the LLM.
        cased_identifiers: A list of all table/column names that require quotes.

    Returns:
        A corrected SQL query with proper quoting.
    """
    corrected_query = query

    for identifier in cased_identifiers:
        # Regex to find the identifier as a whole word, ensuring it's not already quoted.
        # `\b` is a word boundary.
        # `(?<!")` and `(?!")` are negative lookarounds to check for preceding/succeeding quotes.
        pattern = r'\b(?<!")' + re.escape(identifier) + r'(?!")\b'
        replacement = f'"{identifier}"'
        corrected_query = re.sub(pattern, replacement, corrected_query)

    return corrected_query